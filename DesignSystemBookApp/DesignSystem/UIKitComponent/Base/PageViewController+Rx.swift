//
//  RxPageViewController.swift
//  DesignSystemBookApp
//
//  Created by DOYEON LEE on 7/4/24.
//

import UIKit

import RxSwift
import RxCocoa

/**
 
 ```swift
 enum TestViewPage: PageType {
     case first
     case second
     case third
     
     var viewController: UIViewController {
         switch self {
         case .first:
             let vc = UIViewController()
             vc.view.backgroundColor = .gray02
             return vc
         case .second:
             let vc = UIViewController()
             vc.view.backgroundColor = .gray03
             return vc
         case .third:
             let vc = UIViewController()
             vc.view.backgroundColor = .gray05
             return vc
         }
     }
 }
```
 
 ```swift
 
 let pageViewController = RxPageViewController<TestViewPage>(pages: [.first, .second, .third])
pageViewController.setupHirachy(self)
 
 pageViewController.view.snp.makeConstraints { make in
     make.edges.equalToSuperview()
 }
 
 // You can observe when the page changes by dragging.
 pageViewController.onMove
     .subscribe(onNext: { page in
         print(page) // result: first or second or third
     })
     .disposed(by: disposeBag)
 ```
 */
// TODO: 주석 달기...
// viewController가 동적으로 바뀔 가능성을..염두에 둬야하나
// 혹은 외부에서 viewController에 접근할 가능성.. 등등
// 그럼 dict를 이용하기보다도 그냥 pages 인덱스로 매치되는 배열을 두자..그리고 접근가능하게 열어놓는거임
// pages도 열어놓고 didSet으로 viewcontroller도 업데이트치기...흐음
public protocol PageType: Hashable {
    var viewController: UIViewController { get }
}

open class RxPageViewController<Page: PageType>: UIPageViewController, UIPageViewControllerDataSource {
    // MARK: Event
    /// 페이지 변경시 변경 완료 후 현재 페이지가 방출되는 subject
    public let onMove = PublishSubject<Page>()
    
    // MARK: Public property
    public var pageIndex: Binder<Page> {
        return Binder(self) { (pageViewController: RxPageViewController, page: Page) in
            guard let pageIndex = pageViewController.pages.firstIndex(of: page) else { return }
            pageViewController.moveToPage(at: pageIndex)
        }
    }
    
    // MARK: Private property
    /// A page enum list injected
    private var pages: [Page] = []
    
    /// The View Controller generated by the computed property is accessed once and cached so that it is not regenerated.
    private var viewControllersDict: [Page: UIViewController] = [:]
    
    /// It need to determine the animation direction when changing pages from the outside(user drag).
    private var currentPageIndex: Int?
    
    // MARK: DisposeBag
    private let disposeBag = DisposeBag()
    
    // MARK: Initializer
    init(
        pages: [Page],
        transitionStyle style: UIPageViewController.TransitionStyle = .scroll,
        navigationOrientation: UIPageViewController.NavigationOrientation = .horizontal
    ) {
        self.pages = pages
        
        super.init(
            transitionStyle: style,
            navigationOrientation: navigationOrientation,
            options: nil
        )
        
        setupDeleagte()
        setupFirstView()
        setupBind()
    }
    
    public required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: Setup
    public func setupHirachy(_ parent: UIViewController) {
        parent.addChild(self)
        parent.view.addSubview(self.view)
        self.didMove(toParent: parent)
    }
    
    private func setupDeleagte() {
        self.dataSource = self
    }
    
    private func setupFirstView() {
        if let firstPage = pages.first {
            let firstViewController = firstPage.viewController
            viewControllersDict[firstPage] = firstViewController
            setViewControllers([firstViewController], direction: .forward, animated: true, completion: nil)
        }
        currentPageIndex = 0
    }
    
    private func setupBind() {
        self.rx.didFinishAnimating
            .subscribe(onNext: { [weak self] (_, _, transitionCompleted) in
                guard let self = self, transitionCompleted else { return }
                if let currentViewController = self.viewControllers?.first,
                   let currentPage = self.pages.first(where: {
                       self.viewControllersDict[$0] == currentViewController
                   }) {
                    self.currentPageIndex = self.pages.firstIndex(of: currentPage)
                    self.onMove.onNext(currentPage)
                }
            })
            .disposed(by: disposeBag)
    }
    
    // MARK: Data source
    public func pageViewController(
        _ pageViewController: UIPageViewController,
        viewControllerBefore viewController: UIViewController
    ) -> UIViewController? {
        guard let currentIndex = pages
            .firstIndex(where: { viewControllersDict[$0] == viewController })
        else { return nil }
        
        guard currentIndex > 0 else { return nil }

        let destination = pages[currentIndex - 1]
        return findViewController(for: destination)
    }
    
    public func pageViewController(
        _ pageViewController: UIPageViewController,
        viewControllerAfter viewController: UIViewController
    ) -> UIViewController? {
        guard let currentIndex = pages
            .firstIndex(where: { viewControllersDict[$0] == viewController })
        else { return nil }
        
        guard currentIndex < (pages.count - 1) else { return nil }
        
        let destination = pages[currentIndex + 1]
        return findViewController(for: destination)
    }
    
    private func findViewController(for page: Page) -> UIViewController {
        if let viewController = viewControllersDict[page] {
            return viewController
        } else {
            let newViewController = page.viewController
            viewControllersDict[page] = newViewController
            return newViewController
        }
    }
    
    /// Move to specific page
    private func moveToPage(at index: Int) {
        let selectedPage = pages[index].viewController
        let direction: UIPageViewController.NavigationDirection = index 
            > (currentPageIndex ?? 0) ? .forward : .reverse
        
        setViewControllers([selectedPage], direction: direction, animated: true, completion: nil)
        
        currentPageIndex = index
    }
}

// MARK: - Delegate extension
extension Reactive where Base: UIPageViewController {
    private var delegate: DelegateProxy<UIPageViewController, UIPageViewControllerDelegate> {
        return RxPageViewControllerProxy.proxy(for: self.base)
    }
    
    public var didFinishAnimating: Observable<(
        finished: Bool,
        previousViewControllers: [UIViewController],
        transitionCompleted: Bool
    )> {
        return delegate
            .methodInvoked(
                #selector(
                    UIPageViewControllerDelegate.pageViewController(
                        _:didFinishAnimating:previousViewControllers:transitionCompleted:
                    )
                )
            )
            .map { parameters in
                let finished = try castOrThrow(Bool.self, parameters[1])
                let previousViewControllers = try castOrThrow([UIViewController].self, parameters[2])
                let transitionCompleted = try castOrThrow(Bool.self, parameters[3])
                
                return (finished, previousViewControllers, transitionCompleted)
            }
    }
    
    public var willTransitionTo: Observable<[UIViewController]> {
        return delegate
            .methodInvoked(
                #selector(
                    UIPageViewControllerDelegate.pageViewController(_:willTransitionTo:)
                )
            )
            .map { parameters in
                return try castOrThrow([UIViewController].self, parameters[1])
            }
    }
    
    private func castOrThrow<T>(_ resultType: T.Type, _ object: Any) throws -> T {
        guard let returnValue = object as? T else {
            throw RxCocoaError.castingError(object: object, targetType: resultType)
        }

        return returnValue
    }
}

// MARK: - Delegate Proxy
final class RxPageViewControllerProxy: DelegateProxy<UIPageViewController, UIPageViewControllerDelegate>, DelegateProxyType, UIPageViewControllerDelegate {

    static func registerKnownImplementations() {
        self.register { (pageViewContoller) -> RxPageViewControllerProxy in
            RxPageViewControllerProxy(parentObject: pageViewContoller, delegateProxy: self)
        }
    }

    static func currentDelegate(
        for object: UIPageViewController
    ) -> UIPageViewControllerDelegate? {
        return object.delegate
    }

    static func setCurrentDelegate(
        _ delegate: UIPageViewControllerDelegate?, 
        to object: UIPageViewController
    ) {
        object.delegate = delegate
    }
}
